<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: rigidBody/rigidShape.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: rigidBody/rigidShape.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {gEngine} from "../engineCore/core.js";
import {Vector} from "../lib/vector.js";

/**
 * Abstract class that represents a rigid body
 * @class RigidShape
 */
export class RigidShape {
    /**
     * Constructor of RigidShape class,
     * create an object with the center of mass defined by a vector
     * @param {Vector} massCenter point at which center of mass is located
     * @param {number} mass Rigid Shape mass
     * @param  {number} angle angle in radians
     * @param friction Rigid Shape friction
     * @param restitution Rigid Shape restitution (bounciness) (how much energy is preserved after collision)
     * @param gravity consider Rigid Shape when applying gravity
     * @param info additional info
     */
    constructor(massCenter, mass,  angle, friction, restitution, gravity = true, info = "") {
        if (this.constructor === RigidShape) {
            throw new Error("Abstract classes can't be instantiated.");
        }
        this.massCenter = massCenter;
        this.angle = angle;
        /**
         * Angular velocity is stored as a scalar representing the z-component magnitude of the vector
         * @type {number}
         */
        this.angularVelocity = 0;
        this.angularAcceleration = 0;
        this.boundsRadius = 0;
        this.velocity = new Vector();
        this.acceleration = new Vector();
        this.isGravity = gravity;
        if (this.isGravity) {
            let gravity = gEngine.Core.mGravity.scale(mass);
           this.acceleration =  this.acceleration.add(gravity);
        }
        this.accelerationDrag = new Vector();
        this.type = "";
        this.additionalInfo = "";
        this.mass = mass;
        if (mass === 0) {
            this.massInverse = 0;
        } else {
            this.massInverse = 1 / this.mass;
        }
        this.inertia = 0;
        this.friction = friction;
        this.restitution = restitution;
        this.additionalInfo = info;

        if (this.additionalInfo !== "fuelTank") {
            gEngine.Core.mAllObjects.push(this);
        }
    }

    /**
     * Update RigidBody object with its velocity, move and rotate accordingly
     */
    update() {
        /**
         *  Symplectic Euler Integration
         */
        this.velocity = this.velocity.add(this.acceleration);
        if (this.type !== "circle") {
            for (let i = 0; i &lt; this.vertex.length; i++) {
                this.vertex[i] =  this.vertex[i].add(this.velocity);
            }
        } else {
            this.startpoint = this.startpoint.add(this.velocity)
        }
        this.massCenter = this.massCenter.add(this.velocity);
        this.angularVelocity += this.angularAcceleration;
        this.rotate(this.angularVelocity);
        this.angularAcceleration *= 0;
        this.updateDrag();
    }

    /**
     * Change Rigid Shape velocity due to drag
     */
    updateDrag() {
        for (let i = 0; i &lt; gEngine.Core.mDragAreas.length; i++) {
            let area = gEngine.Core.mDragAreas[i];
            if (this.isInside(area)) {

                this.drag(area);
                this.velocity = this.velocity.add(this.accelerationDrag);
                this.accelerationDrag= this.accelerationDrag.scale(0);
            }
        }
    }

    /**
     * Displace the object by the given vector
     * @param {Vector} s object displacement
     */
    move(s) {
        if (this.type !== "circle") {
            for (let i = 0; i &lt; this.vertex.length; i++) {
                this.vertex[i] = this.vertex[i].add(s);
            }
        } else {
            this.startpoint = this.startpoint.add(s);
        }

        this.massCenter= this.massCenter.add(s);
    }

    /**
     * Support changing of the mass during runtime
     * @param delta mass change
     */
    updateMass(delta) {
        if ( this.mass === 0) return;
        let mass = this.mass;
        this.mass += delta;
        if (this.mass &lt;= 0) {
            this.massInverse = 0;
            this.velocity = new Vector();
            this.acceleration = new Vector();
            this.angularVelocity = new Vector();
            this.angularAcceleration = new Vector();
        } else {
            this.massInverse = 1 / this.mass;

            if (this.isGravity) {
                let accelerationTemp = this.acceleration.copy();

                let gravity = gEngine.Core.mGravity.scale(mass);
                accelerationTemp = accelerationTemp.subtract(gravity);
                gravity = gEngine.Core.mGravity.scale(this.mass);
                this.acceleration =  this.acceleration.add(gravity);
            }

        }
        this.updateInertia();
    }

    updateInertia() {
    }

    displayBounds() {
    }

    /**
     * Function that implements Broad Phase Method to detect collision detection
     * @param otherShape Other object that an object might collide with
     * @return {boolean} Returns true when objects are colliding and false when they are not
     */
    boundTest(otherShape) {
        if (this.massCenter !== null &amp;&amp; otherShape.massCenter !== null) {
            let dis1To2 = otherShape.massCenter.subtract(this.massCenter).copy();
            let radiusSum = this.boundsRadius + otherShape.boundsRadius;
            let distance = dis1To2.mag();

            return !((distance > radiusSum));
        }
    }

    /**
     * Is Rigid Shape inside a Drag Area
     * @param area drag area
     * @return {boolean} is inside
     */
    isInside(area) {
        return this.massCenter.x > area.x &amp;&amp;
            this.massCenter.x &lt; area.x + area.w &amp;&amp;
            this.massCenter.y > area.y &amp;&amp;
            this.massCenter.y &lt; area.y + area.h;
    }

    /**
     * Apply drag to Rigid Shape if it is in a Drag Area
     * @param {DragArea} dragObj
     */
    drag(dragObj) {
        let speed = this.velocity.mag();
        let dragMagnitude = dragObj.c * speed * speed;
        let drag = new Vector();
        drag.x = this.velocity.x;
        drag.y = this.velocity.y;
        drag = drag.normalize();
        drag = drag.scale(dragMagnitude);
        drag = drag.scale(-1);
        this.applyForce(drag);
    }

    /**
     * Apply drag force
     * @param {Vector} force
     */
    applyForce(force) {
        let f = force;
        f = f.scale(this.massInverse);
        this.accelerationDrag = this.accelerationDrag.add(f);
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Bullet.html">Bullet</a></li><li><a href="Bullet_Bullet.html">Bullet</a></li><li><a href="BulletSource.html">BulletSource</a></li><li><a href="BulletSource_BulletSource.html">BulletSource</a></li><li><a href="Circle_Circle.html">Circle</a></li><li><a href="CollisionInfo.html">CollisionInfo</a></li><li><a href="CollisionInfo_CollisionInfo.html">CollisionInfo</a></li><li><a href="DragArea.html">DragArea</a></li><li><a href="DragArea_DragArea.html">DragArea</a></li><li><a href="FuelTank.html">FuelTank</a></li><li><a href="FuelTank_FuelTank.html">FuelTank</a></li><li><a href="Mover_Mover.html">Mover</a></li><li><a href="PlayerShip.html">PlayerShip</a></li><li><a href="PlayerShip_PlayerShip.html">PlayerShip</a></li><li><a href="Rectangle_Rectangle.html">Rectangle</a></li><li><a href="RigidShape.html">RigidShape</a></li><li><a href="RigidShape_RigidShape.html">RigidShape</a></li><li><a href="SineWave.html">SineWave</a></li><li><a href="Terrain.html">Terrain</a></li><li><a href="Triangle_Triangle.html">Triangle</a></li><li><a href="Vector.html">Vector</a></li><li><a href="Vector_Vector.html">Vector</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clickBtn">clickBtn</a></li><li><a href="global.html#displayUI">displayUI</a></li><li><a href="global.html#drawButton">drawButton</a></li><li><a href="global.html#drawLevelSky">drawLevelSky</a></li><li><a href="global.html#engineCore">engineCore</a></li><li><a href="global.html#gEngine">gEngine</a></li><li><a href="global.html#getMousePos">getMousePos</a></li><li><a href="global.html#handleKeyInput">handleKeyInput</a></li><li><a href="global.html#isInside">isInside</a></li><li><a href="global.html#lastRenderTime">lastRenderTime</a></li><li><a href="global.html#mainGame">mainGame</a></li><li><a href="global.html#playButton">playButton</a></li><li><a href="global.html#screen">screen</a></li><li><a href="global.html#setBunkers">setBunkers</a></li><li><a href="global.html#setDrag">setDrag</a></li><li><a href="global.html#setFuel">setFuel</a></li><li><a href="global.html#setScene">setScene</a></li><li><a href="global.html#setTerrain">setTerrain</a></li><li><a href="global.html#setUp">setUp</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#startGame">startGame</a></li><li><a href="global.html#ui">ui</a></li><li><a href="global.html#updateUI">updateUI</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Wed Sep 14 2022 21:38:52 GMT+0200 (czas Å›rodkowoeuropejski letni)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
